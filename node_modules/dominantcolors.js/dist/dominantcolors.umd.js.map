{"version":3,"file":"dominantcolors.umd.js","sources":["../src/helper.ts","../src/medianCut.ts","../src/index.ts"],"sourcesContent":["function toHex(count: number): string {\n  let hex: string = Math.round(count)\n    .toString(16)\n    .toUpperCase();\n  return hex.padStart(2, \"0\");\n}\n\nexport function getRGBFromData(\n  data: Uint8ClampedArray | number[],\n  idx: number\n): {\n  redData: number;\n  greenData: number;\n  blueData: number;\n} {\n  let redData = data[idx * 4];\n  let greenData = data[idx * 4 + 1];\n  let blueData = data[idx * 4 + 2];\n  return {\n    redData,\n    greenData,\n    blueData\n  };\n}\n\nexport async function getImageData(src: string): Promise<Uint8ClampedArray> {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.src = src;\n\n    image.onload = () => {\n      const { width, height } = image;\n      const canvas = document.createElement(\"canvas\");\n      canvas.setAttribute(\"width\", String(width));\n      canvas.setAttribute(\"width\", String(height));\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(image, 0, 0, width, height);\n      const { data } = context.getImageData(0, 0, width, height);\n      resolve(data);\n    };\n\n    image.onerror = image.onabort = () => {\n      reject(new Error(\"Load image failed, please try again.\"));\n    };\n  });\n}\n\nexport function getColor(\n  data: Uint8ClampedArray | number[],\n  format: string = \"hex\"\n): Object | string {\n  const pixelCount = data.length / 4;\n  let red: number = 0;\n  let green: number = 0;\n  let blue: number = 0;\n\n  for (let i = 0; i < pixelCount; i += 1) {\n    const { redData, greenData, blueData } = getRGBFromData(data, i);\n    red += redData;\n    green += greenData;\n    blue += blueData;\n  }\n  red = red / pixelCount;\n  green = green / pixelCount;\n  blue = blue / pixelCount;\n\n  if (format === \"rgb\") {\n    return {\n      red: Math.round(red),\n      green: Math.round(green),\n      blue: Math.round(blue)\n    };\n  }\n\n  if (format === \"hex\") {\n    return `#${toHex(red)}${toHex(green)}${toHex(blue)}`;\n  }\n}\n","import { getRGBFromData } from \"./helper\";\n\nconst MIN_COLOR = 0;\nconst MAX_COLOR = 255;\n\ninterface IColorRange {\n  red: {\n    min: number;\n    max: number;\n  };\n  green: {\n    min: number;\n    max: number;\n  };\n  blue: {\n    min: number;\n    max: number;\n  };\n}\n\ninterface IColorCount {\n  color: number;\n  count: number;\n}\n\nexport class ColorBox {\n  public data;\n  public rank: number;\n  public colorRange: IColorRange;\n  public total: number;\n  private getColorRange: Function = getColorRange;\n  public getVolume: Function = getVolume;\n\n  constructor(data: Uint8ClampedArray | number[]) {\n    this.data = data;\n    this.total = data.length / 4;\n    this.colorRange = this.getColorRange(data);\n    this.rank = this.getVolume(this.colorRange) * this.total;\n  }\n}\n\nfunction getColorRange(data: Uint8ClampedArray | number[]): IColorRange {\n  const pixelCount: number = data.length / 4;\n  let minRed: number = MAX_COLOR;\n  let maxRed: number = MIN_COLOR;\n  let minGreen: number = MAX_COLOR;\n  let maxGreen: number = MIN_COLOR;\n  let minBlue: number = MAX_COLOR;\n  let maxBlue: number = MIN_COLOR;\n\n  for (let i = 0; i < pixelCount; i += 1) {\n    const { redData, greenData, blueData } = getRGBFromData(data, i);\n\n    minRed = redData < minRed ? redData : minRed;\n    maxRed = redData > maxRed ? redData : maxRed;\n    minGreen = greenData < minGreen ? redData : minGreen;\n    maxGreen = greenData > maxGreen ? redData : maxGreen;\n    minBlue = blueData < minBlue ? redData : minBlue;\n    maxBlue = blueData > maxBlue ? redData : maxBlue;\n  }\n\n  return {\n    red: {\n      min: minRed,\n      max: maxRed\n    },\n    green: {\n      min: minGreen,\n      max: maxGreen\n    },\n    blue: {\n      min: minBlue,\n      max: maxBlue\n    }\n  };\n}\n\nfunction getVolume(colorRange: IColorRange): number {\n  const { red, green, blue } = colorRange;\n  return (red.max - red.min) * (green.max - green.min) * (blue.max - blue.min);\n}\n\nfunction getCutEdgeIdx(colorRange: IColorRange): number {\n  const { red, green, blue } = colorRange;\n  const edges: number[] = [\n    red.max - red.min,\n    green.max - green.min,\n    blue.max - blue.min\n  ];\n  const maxEdge: number = Math.max(...edges);\n\n  return edges.indexOf(maxEdge);\n}\n\nfunction getMedianColor(colorBox: ColorBox, cutEdgeIdx: number): number {\n  const colors: Object = {};\n  let colorCounts: IColorCount[] = [];\n  let color: number;\n  let total: number = 0;\n  let medianIdx: number = 0;\n\n  for (let i = 0; i < colorBox.total; i += 1) {\n    color = colorBox.data[i * 4 + cutEdgeIdx];\n    if (!colors[color]) {\n      colors[color] = 1;\n    } else {\n      colors[color] += 1;\n    }\n  }\n  for (const key in colors) {\n    color = parseInt(key, 10);\n    if (color !== 0) {\n      colorCounts.push({\n        color,\n        count: colors[key]\n      });\n    }\n  }\n  colorCounts.sort((prev, next) => prev.count - next.count);\n  for (let i = 0; i < colorCounts.length; i += 1) {\n    total += colorCounts[i].count;\n    if (total >= colorBox.total / 2 || i === colorCounts.length - 1) {\n      medianIdx = i;\n      break;\n    }\n  }\n\n  return colorCounts[medianIdx].color;\n}\n\nfunction cutBox(colorBox: ColorBox): ColorBox[] {\n  const cutEdgeIdx: number = getCutEdgeIdx(colorBox.colorRange);\n  const medianColor: number = getMedianColor(colorBox, cutEdgeIdx);\n  let leftData: number[] = [];\n  let rightData: number[] = [];\n  let targetData: number[];\n  for (let i = 0; i < colorBox.total; i += 1) {\n    if (colorBox.data[i * 4 + cutEdgeIdx] < medianColor) {\n      targetData = leftData;\n    } else if (colorBox.data[i * 4 + cutEdgeIdx] > medianColor) {\n      targetData = rightData;\n    } else {\n      targetData = leftData.length < rightData.length ? leftData : rightData;\n    }\n    targetData.push(colorBox.data[i * 4]);\n    targetData.push(colorBox.data[i * 4 + 1]);\n    targetData.push(colorBox.data[i * 4 + 2]);\n    targetData.push(colorBox.data[i * 4 + 3]);\n  }\n  const leftBox: ColorBox = new ColorBox(leftData);\n  const rightBox: ColorBox = new ColorBox(rightData);\n\n  return [leftBox, rightBox];\n}\n\nexport default function medianCut(\n  data: Uint8ClampedArray | number[],\n  count: number = 1\n): ColorBox[] {\n  let colorBox: ColorBox = new ColorBox(data);\n  let boxes: ColorBox[] = [colorBox];\n\n  while (boxes.length < count) {\n    boxes.sort((prev, next) => prev.rank - next.rank);\n    colorBox = boxes.pop();\n    const cutBoxes: ColorBox[] = cutBox(colorBox);\n    boxes = boxes.concat(cutBoxes);\n  }\n\n  return boxes;\n}\n","import medianCut from \"./medianCut\";\nimport { getColor, getImageData } from \"./helper\";\n\ninterface IOptions {\n  count: number;\n  colorFormat: string;\n  method: string;\n  omitTransparentPixel: boolean;\n}\n\nconst defaultOptions = {\n  count: 4,\n  colorFormat: \"hex\",\n  omitTransparentPixel: true,\n  method: \"medianCut\"\n};\n\nexport default async function(\n  image: string | Uint8ClampedArray | number[],\n  options: IOptions = defaultOptions\n) {\n  if (typeof image === \"string\") {\n    image = await getImageData(image);\n  }\n\n  options = Object.assign(defaultOptions, options);\n  const { count, colorFormat, method, omitTransparentPixel } = options;\n  if (omitTransparentPixel) {\n    let tempImage = image;\n    image = [];\n    for (let i = 0; i < tempImage.length / 4; i += 1) {\n      if (tempImage[i * 4 + 3]) {\n        image.push(tempImage[i * 4]);\n        image.push(tempImage[i * 4 + 1]);\n        image.push(tempImage[i * 4 + 2]);\n        image.push(tempImage[i * 4 + 3]);\n      }\n    }\n  }\n\n  const func = method === \"medianCut\" ? medianCut : () => [];\n  const boxes = func(image, count);\n  return boxes.slice(0, count).map(box => getColor(box.data, colorFormat));\n}\n"],"names":["toHex","count","Math","round","toString","toUpperCase","padStart","getRGBFromData","data","idx","const","MIN_COLOR","MAX_COLOR","ColorBox","constructor","getColorRange","getVolume","total","length","colorRange","this","rank","pixelCount","minRed","maxRed","minGreen","maxGreen","minBlue","maxBlue","i","redData","greenData","blueData","red","min","max","green","blue","cutBox","colorBox","edges","maxEdge","targetData","cutEdgeIdx","indexOf","medianColor","color","colors","colorCounts","medianIdx","key","parseInt","push","sort","prev","next","let","getMedianColor","leftData","rightData","defaultOptions","colorFormat","omitTransparentPixel","method","image","options","Object","assign","tempImage","boxes","cutBoxes","pop","concat","slice","map","box","format","getColor","src","Promise","resolve","reject","Image","onload","canvas","document","createElement","setAttribute","String","width","height","context","getContext","drawImage","getImageData","onerror","onabort","Error"],"mappings":"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"}