function toHex(count) {
  var hex = Math.round(count).toString(16).toUpperCase();
  return hex.padStart(2, "0");
}

var getImageData = function (src) {
  try {
    return Promise.resolve(new Promise(function (resolve, reject) {
      var image = new Image();
      image.src = src;

      image.onload = function () {
        var width = image.width;
        var height = image.height;
        var canvas = document.createElement("canvas");
        canvas.setAttribute("width", String(width));
        canvas.setAttribute("width", String(height));
        var context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        var ref = context.getImageData(0, 0, width, height);
        var data = ref.data;
        resolve(data);
      };

      image.onerror = image.onabort = function () {
        reject(new Error("Load image failed, please try again."));
      };
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};
function getRGBFromData(data, idx) {
  var redData = data[idx * 4];
  var greenData = data[idx * 4 + 1];
  var blueData = data[idx * 4 + 2];
  return {
    redData: redData,
    greenData: greenData,
    blueData: blueData
  };
}
function getColor(data, format) {
  if ( format === void 0 ) format = "hex";

  var pixelCount = data.length / 4;
  var red = 0;
  var green = 0;
  var blue = 0;

  for (var i = 0; i < pixelCount; i += 1) {
    var ref = getRGBFromData(data, i);
    var redData = ref.redData;
    var greenData = ref.greenData;
    var blueData = ref.blueData;
    red += redData;
    green += greenData;
    blue += blueData;
  }

  red = red / pixelCount;
  green = green / pixelCount;
  blue = blue / pixelCount;

  if (format === "rgb") {
    return {
      red: Math.round(red),
      green: Math.round(green),
      blue: Math.round(blue)
    };
  }

  if (format === "hex") {
    return ("#" + (toHex(red)) + (toHex(green)) + (toHex(blue)));
  }
}

var MIN_COLOR = 0;
var MAX_COLOR = 255;
var ColorBox = function ColorBox(data) {
  this.getColorRange = getColorRange;
  this.getVolume = getVolume;
  this.data = data;
  this.total = data.length / 4;
  this.colorRange = this.getColorRange(data);
  this.rank = this.getVolume(this.colorRange) * this.total;
};

function getColorRange(data) {
  var pixelCount = data.length / 4;
  var minRed = MAX_COLOR;
  var maxRed = MIN_COLOR;
  var minGreen = MAX_COLOR;
  var maxGreen = MIN_COLOR;
  var minBlue = MAX_COLOR;
  var maxBlue = MIN_COLOR;

  for (var i = 0; i < pixelCount; i += 1) {
    var ref = getRGBFromData(data, i);
    var redData = ref.redData;
    var greenData = ref.greenData;
    var blueData = ref.blueData;
    minRed = redData < minRed ? redData : minRed;
    maxRed = redData > maxRed ? redData : maxRed;
    minGreen = greenData < minGreen ? redData : minGreen;
    maxGreen = greenData > maxGreen ? redData : maxGreen;
    minBlue = blueData < minBlue ? redData : minBlue;
    maxBlue = blueData > maxBlue ? redData : maxBlue;
  }

  return {
    red: {
      min: minRed,
      max: maxRed
    },
    green: {
      min: minGreen,
      max: maxGreen
    },
    blue: {
      min: minBlue,
      max: maxBlue
    }
  };
}

function getVolume(colorRange) {
  var red = colorRange.red;
  var green = colorRange.green;
  var blue = colorRange.blue;
  return (red.max - red.min) * (green.max - green.min) * (blue.max - blue.min);
}

function getCutEdgeIdx(colorRange) {
  var red = colorRange.red;
  var green = colorRange.green;
  var blue = colorRange.blue;
  var edges = [red.max - red.min, green.max - green.min, blue.max - blue.min];
  var maxEdge = Math.max.apply(Math, edges);
  return edges.indexOf(maxEdge);
}

function getMedianColor(colorBox, cutEdgeIdx) {
  var colors = {};
  var colorCounts = [];
  var color;
  var total = 0;
  var medianIdx = 0;

  for (var i = 0; i < colorBox.total; i += 1) {
    color = colorBox.data[i * 4 + cutEdgeIdx];

    if (!colors[color]) {
      colors[color] = 1;
    } else {
      colors[color] += 1;
    }
  }

  for (var key in colors) {
    color = parseInt(key, 10);

    if (color !== 0) {
      colorCounts.push({
        color: color,
        count: colors[key]
      });
    }
  }

  colorCounts.sort(function (prev, next) { return prev.count - next.count; });

  for (var i$1 = 0; i$1 < colorCounts.length; i$1 += 1) {
    total += colorCounts[i$1].count;

    if (total >= colorBox.total / 2 || i$1 === colorCounts.length - 1) {
      medianIdx = i$1;
      break;
    }
  }

  return colorCounts[medianIdx].color;
}

function cutBox(colorBox) {
  var cutEdgeIdx = getCutEdgeIdx(colorBox.colorRange);
  var medianColor = getMedianColor(colorBox, cutEdgeIdx);
  var leftData = [];
  var rightData = [];
  var targetData;

  for (var i = 0; i < colorBox.total; i += 1) {
    if (colorBox.data[i * 4 + cutEdgeIdx] < medianColor) {
      targetData = leftData;
    } else if (colorBox.data[i * 4 + cutEdgeIdx] > medianColor) {
      targetData = rightData;
    } else {
      targetData = leftData.length < rightData.length ? leftData : rightData;
    }

    targetData.push(colorBox.data[i * 4]);
    targetData.push(colorBox.data[i * 4 + 1]);
    targetData.push(colorBox.data[i * 4 + 2]);
    targetData.push(colorBox.data[i * 4 + 3]);
  }

  var leftBox = new ColorBox(leftData);
  var rightBox = new ColorBox(rightData);
  return [leftBox, rightBox];
}

function medianCut(data, count) {
  if ( count === void 0 ) count = 1;

  var colorBox = new ColorBox(data);
  var boxes = [colorBox];

  while (boxes.length < count) {
    boxes.sort(function (prev, next) { return prev.rank - next.rank; });
    colorBox = boxes.pop();
    var cutBoxes = cutBox(colorBox);
    boxes = boxes.concat(cutBoxes);
  }

  return boxes;
}

var defaultOptions = {
  count: 4,
  colorFormat: "hex",
  omitTransparentPixel: true,
  method: "medianCut"
};
var index = (function (image, options) {
  if ( options === void 0 ) options = defaultOptions;

  try {
    function _temp2() {
      options = Object.assign(defaultOptions, options);
      var count = options.count;
      var colorFormat = options.colorFormat;
      var method = options.method;
      var omitTransparentPixel = options.omitTransparentPixel;

      if (omitTransparentPixel) {
        var tempImage = image;
        image = [];

        for (var i = 0; i < tempImage.length / 4; i += 1) {
          if (tempImage[i * 4 + 3]) {
            image.push(tempImage[i * 4]);
            image.push(tempImage[i * 4 + 1]);
            image.push(tempImage[i * 4 + 2]);
            image.push(tempImage[i * 4 + 3]);
          }
        }
      }

      var func = method === "medianCut" ? medianCut : function () { return []; };
      var boxes = func(image, count);
      return boxes.slice(0, count).map(function (box) { return getColor(box.data, colorFormat); });
    }

    var _temp = function () {
      if (typeof image === "string") {
        return Promise.resolve(getImageData(image)).then(function (_getImageData) {
          image = _getImageData;
        });
      }
    }();

    return Promise.resolve(_temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp));
  } catch (e) {
    return Promise.reject(e);
  }
});

module.exports = index;
